import groovy.json.JsonSlurper

def jsonSlurper = new JsonSlurper()

def configFile = "./config.json"
if (hasProperty("config")) {
    configFile = config
}

def fileObj = new File(configFile)
if (!fileObj.isFile()) {
    println("Not found config file " + configFile)
    return
}

def data = jsonSlurper.parse(fileObj)
ext.configObj = data

//if (hasProperty("configKey")) {
//    data = data[configKey]
//}

//get_data_value(key, env) {
//    if 'env_overwrite' in data.keys() and env in data['env_overwrite']:
//    if key in data['env_overwrite'][env].keys():
//    return data['env_overwrite'][env][key]
//    return data[key]
//}

println("Read config: ${data}")
//rootProject.name = data['app_name']

ext.getConfigValue = { configData, key, env, defaultValue = null ->
    env = env.toString()
    // Method body here
    println("getConfigValue ${key}, ${env}")
    if ('env_overwrite' in configData.keySet() && configData['env_overwrite'].containsKey(env)) {
        if (key in configData['env_overwrite'][env].keySet())
            return configData['env_overwrite'][env][key]
    }
    if (key in configData.keySet()) {
        return configData[key]
    }
    return defaultValue
}


ext.getConfigConnectValue = { configData, key, env, defaultValue = null ->
    env = env.toString()
    def connectKey
    if (!isDockerBuild()) {
        connectKey = env + "_not_docker"
    } else {
        connectKey = env
    }
    // Method body here
    println("getConfigConnectValue ${key}, ${connectKey}")
    if ('connected' in configData.keySet() && configData['connected'].containsKey(connectKey)) {
        if (key in configData['connected'][connectKey].keySet())
            return configData['connected'][connectKey][key]
    }
    if ('common' in configData['connected'].keySet() && key in configData['connected']['common'].keySet()) {
        return configData['connected']['common'][key]
    }
    if (connectKey in configData.keySet()) {
        return configData[connectKey]
    }
    return getConfigValue(configData, key, env, defaultValue)
}


ext.getSubConfigConnectValue = { name, key, env, defaultValue = null ->
    env = env.toString()
    println("getSubConfigConnectValue ${name}, ${key}, ${env} ")
    if (name in data.keySet()) {
        def configData = data[name]
        return getConfigConnectValue(configData, key, env, defaultValue)
    }
    return defaultValue
}

ext.getSubConfigValue = { name, key, env, defaultValue = null ->
    env = env.toString()
    println("getSubConfigValue ${name}, ${key}, ${env} ")
    if (name in data.keySet()) {
        def configData = data[name]
//        def arr = ['local', 'dev']
//        println("get env_overwrite ${name}, ${key}, env:${env}, ${configData['env_overwrite'].keySet()}," +
//                "${'env_overwrite' in configData.keySet()},env in env_overwrite:${env.toString() in configData['env_overwrite'].keySet()}, " +
//                "${'local' in arr}, ${arr}, ss${configData['env_overwrite'].containsKey(env)}")
        return getConfigValue(configData, key, env, defaultValue)
    }
    return defaultValue
}


ext.addCustomJvmArgs = { argsArr ->
    if (project.hasProperty('customJvmArgs')) {
        ext.customJvmArgs += argsArr
    } else {
        ext.customJvmArgs = argsArr
    }
}


def autoConfigMap = new TreeMap<String, String>();
if (getSubConfigValue('infra_redis', 'enable', env)) {
    def host = getSubConfigConnectValue('infra_redis', 'host', env)
    def password = getSubConfigConnectValue('infra_redis', 'password', env)
    def port = getSubConfigConnectValue('infra_redis', 'port', env)

    autoConfigMap.put("flycat.redis.primary.enabled", true)
    autoConfigMap.put("flycat.redis.primary.host", host)
    autoConfigMap.put("flycat.redis.primary.port", port)
    autoConfigMap.put("flycat.redis.primary.password", password)
//    addCustomJvmArgs(["-Dflycat.redis.primary.enabled=true",
//                      "-Dflycat.redis.primary.host=${host}".toString(),
//                      "-Dflycat.redis.primary.port=${port}".toString(),
//                      "-Dflycat.redis.primary.password=${password}".toString()])
}

if (getSubConfigValue('infra_nacos', 'enable', env)) {
    def host = getSubConfigConnectValue('infra_nacos', 'host', env)
    def port = getSubConfigConnectValue('infra_nacos', 'port', env)

    def nacosUser = getSubConfigConnectValue('infra_nacos', 'nacos_user', env)
    def nacosPassword = getSubConfigConnectValue('infra_nacos', 'nacos_password', env)

    autoConfigMap.put("flycat.nacos.config.server-addr", "${host}:${port}".toString())
    autoConfigMap.put("flycat.nacos.config.user", "${nacosUser}".toString())
    autoConfigMap.put("flycat.nacos.config.password", "${nacosPassword}".toString())
//    addCustomJvmArgs(["-Dflycat.nacos.config.server-addr=${host}:${port}".toString(),
//                      "-Dflycat.nacos.config.user=${nacosUser}".toString(),
//                      "-Dflycat.nacos.config.password=${nacosPassword}".toString()
//    ])
}


if (getSubConfigValue('infra_sba', 'enable', env)) {
    def user = getSubConfigConnectValue('infra_sba', 'sba_user', env)
    def password = getSubConfigConnectValue('infra_sba', 'sba_password', env)

    def meta_user = getSubConfigConnectValue('infra_sba', 'meta_user', env)
    def meta_password = getSubConfigConnectValue('infra_sba', 'meta_password', env)
    def client_url = getSubConfigConnectValue('infra_sba', 'client_url', env)

    autoConfigMap.put("spring.security.user.name", user)
    autoConfigMap.put("spring.security.user.password", password)
    autoConfigMap.put("spring.boot.admin.client.username", meta_user)
    autoConfigMap.put("spring.boot.admin.client.password", meta_password)
    autoConfigMap.put("spring.boot.admin.client.metadata.user.name", '${spring.security.user.name}')
    autoConfigMap.put("spring.boot.admin.client.metadata.user.password", '${spring.security.user.password}')

    autoConfigMap.put("spring.boot.admin.client.url", client_url)
//"spring.security.user.name": "zgq",
//"spring.security.user.password": "zgq",
//"spring.boot.admin.client.username": "zgqq",
//"spring.boot.admin.client.password": "zgqq",
//"spring.boot.admin.client.metadata.user.name": "${spring.security.user.name}",
//"spring.boot.admin.client.metadata.user.password": "${spring.security.user.password}",

}



//def executeDockerBuild = false
//def executingTasks = project.gradle.startParameter.taskNames
//if (executingTasks != null && !executingTasks.isEmpty()) {
//    executeDockerBuild = 'jib' in executingTasks
//            || 'jibDockerbuild' in executingTasks
//}


//println("Executing docker build, ${executeDockerBuild}, ${executingTasks}")
//if (isDockerBuild()) {
//    ext.profile = getSubConfigValue('docker_profiles', env.toString(), env)
//    println("Executing docker build, use profile:${profile}")
//}

ext.profile = env
if (isDockerBuild()) {
    ext.profile = "docker" + profile
}


def profilePath = fileObj.getParent() + "/profile.json"
def config = new File(profilePath)
if (!config.isFile()) {
    println("Not found profile file " + profilePath)
    return
}


def profileConf = jsonSlurper.parse(config)

def handleConf = { configMap, profileConfig ->
    profileConfig.each { key, value ->
        if (key != "env_overwrite") {
            if (key in configMap.keySet()) {
                configMap.remove(key)
            }
            configMap.put(key, value)
//                common += (key + "=" + value +"\n")
        }
    }

    if ("env_overwrite" in profileConfig.keySet()) {
        if (env.toString() in profileConfig['env_overwrite'].keySet()) {
            profileConfig['env_overwrite'][env.toString()].each { skey, svalue ->
                if (key in configMap.keySet()) {
                    configMap.remove(key)
                }
                configMap.put(key, value)
            }
        }
    }
}


def configMap = new TreeMap<String, String>(autoConfigMap);
def resourcesDir = sourceSets.main.output.resourcesDir
resourcesDir.mkdirs()

def common = ""
def commonConfig = profileConf['common']
handleConf(configMap, commonConfig)

if (isDockerBuild()) {
    def dockerConfig = profileConf['docker']
    handleConf(configMap, dockerConfig)
}

configMap.each { key, value ->
    common += (key + "=" + value + "\n")
}

println("Handling resource")
println(common)
def applicationConfigFile = new File(resourcesDir, "application-" + profile + ".properties")
println("Write config to file "+ applicationConfigFile.getAbsolutePath())
applicationConfigFile.text = common

//profile_docker
//profile_common