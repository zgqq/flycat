if (ignoredEnv) {
    return
}

ext.jvmArgs = applicationDefaultJvmArgs

System.setProperty("jib.httpTimeout", '0')


jib {

    from {
//        image = 'amazoncorretto:8u232'
//        image = 'https://reg.qiniu.com/open-flycat/flycat:latest'
        image = 'https://reg.qiniu.com/open-flycat/flycat-openj9:latest'
    }

    extraDirectories {
        paths = [file('build/jib')]
    }

    to {
        image = dockerImage
        credHelper = 'docker-credential-osxkeychain'
        tags = [env.toString() + '-' + (new Date().format("yyyyMMdd_HHmmss")).toString(), 'latest']
        auth {
            println "image  $dockerImage username $dockerUsername"
            username = dockerUsername
            password = dockerPassword
        }
    }

    container {
        jvmFlags = jvmArgs
        mainClass = mainClassName
        ports = [containerPort, debugServerPort + '']
        volumes = ['/app', '/userapp']

        creationTime = 'USE_CURRENT_TIMESTAMP'
    }
//    allowInsecureRegistries = true
}


def updateServer(serverRole, execPath) {
    if (remotes.role(serverRole)) {
        ssh.run {
            session(remotes.role(serverRole)) {
                def gitRepo = "/home/${remote.user}/git-repo/${project.name}/"
                def dockerDir = gitRepo + "deploy/docker/"
                def updateScript = execPath
                executeScript """
                        cd ${gitRepo}
                        git pull 
                        cd ${dockerDir}
                        sh ${updateScript}
                """
                println "Deployed to ${remote.user}@${remote.host}:${gitRepo}"
            }
        }
    }
}

def updateSh = "./update_production.sh"

task dockerRestartProd() {
    doLast {
        def serverRole = 'production'
        updateServer(serverRole, updateSh)
        println "Restarted prod server"
    }
}

task dockerUpdateProd() {
    dependsOn 'jib'
    doLast {
        def serverRole = 'production'
        updateServer(serverRole, updateSh)
        println "Updated prod server"
    }
}

def rollbackSh = "./rollback_production.sh"
task dockerRollbackProd() {
    dependsOn 'jib'
    doLast {
        def serverRole = 'production'
        updateServer(serverRole, rollbackSh)
        println "Updated prod server"
    }
}


def updateTestSh = "./update_test.sh"
task dockerUpdateTest() {
    dependsOn 'jib'
    doLast {
        def serverRole = 'test'
        updateServer(serverRole, updateTestSh)
        println "Updated test server"
    }
}


def execCmd = { command ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine command
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

task dockerUpdateLocal() {
    dependsOn 'jibDockerBuild'
    println(execCmd(['cd', 'deploy/docker', '&&', 'python3','./deploy.py','local']))
}


task setupExtraDir {
    doLast {
        copy {
            from file('build/generated/git/')
            into file('build/jib/project/generated/git/')
        }
        copy {
            from file('src')
            into file('build/jib/project/src/')
        }
        copy {
            from file('build.gradle'), file('settings.gradle'), file('deploy')
            into file('build/jib/project/')
        }
    }
}


tasks.jib.dependsOn tasks.build, tasks.setupExtraDir

tasks.jibDockerBuild.dependsOn tasks.build, tasks.setupExtraDir
