if (!isJibBuildImage() && !isSkaffoldBuild()) {
    logger.info("Not docker build, skipping docker configure")
    return
}
apply plugin: "com.google.cloud.tools.jib"

ext.jvmArgs = applicationDefaultJvmArgs

System.setProperty("jib.httpTimeout", '0')

def executeDockerBuild = false
def executeDockerBuildLocal = false
def executingTasks = project.gradle.startParameter.taskNames
if (executingTasks != null && !executingTasks.isEmpty()) {
    executeDockerBuild = 'jib' in executingTasks
            || 'jibDockerBuild' in executingTasks
    executeDockerBuildLocal = 'jibDockerBuild' in executingTasks
}

//if (executeDockerBuild) {
//    if (!isDocker(env)) {
//        throw new RuntimeException("Executing jib task need to docker env, current:" + env)
//    }
//}

ext.jibPlatform = "linux/arm64"
if (hasProperty("platform")) {
    println("Using specific docker platform, $platform")
    ext.jibPlatform = "$platform"
}

def dockerBaseImage = 'ibm-semeru-runtimes:open-17-jre-jammy'
def tag = "default"
if (hasProperty("dockerBaseImage")) {
    dockerBaseImage = ext.dockerBaseImage
    tag = "config"
}
println("Using ${dockerBaseImage} image by ${tag}")



import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;


def processTemplateFile(className, jvmArgsString) {
    def inputFile = file('docker_entrypoint.sh')
    println("Repalce file, exists:"+ inputFile.exists())
    if (inputFile.exists()) {
        def outputFile = file("${buildDir}/generated/docker_entrypoint.sh")
        println("To file, exists:"+ outputFile.getAbsolutePath())
        def content = inputFile.text
        // Replace placeholder variables with actual values
        content = content.replace('${className}', className)
        content = content.replace('${jvmFlags}', jvmArgsString)
        // Write the updated content to a new file in the build directory
        Files.write(Paths.get(outputFile.toURI()), content.getBytes())
        // Set the file permissions to 0755
        Set<PosixFilePermission> permissions = PosixFilePermissions.fromString("rwxr-xr-x");
        Files.setPosixFilePermissions(outputFile.toPath(), permissions);
        println "Processed template file: ${outputFile}"
        return true
    } else {
        println "Template file not found"
        return false
    }
}

processTemplateFile(mainClassName, jvmArgs.join(" "))

jib {
    from {
//        image = 'amazoncorretto:8u232'
//        image = 'https://reg.qiniu.com/open-flycat/flycat:latest'
//        image = 'https://reg.qiniu.com/open-flycat/flycat-openj9:latest'
//        image = 'zgqq/flycat-jdk17:latest'
        image = dockerBaseImage
        platforms {
            if (jibPlatform == "linux/amd64") {
                println("Using docker platform, linux/amd64, specific platform: $jibPlatform")
                platform {
                    architecture = 'amd64'
                    os = 'linux'
                }
            } else {
                println("Using docker platform, linux/arm64, specific platform: $jibPlatform")
                platform {
                    architecture = 'arm64'
                    os = 'linux'
                }
            }
        }

        if (project.hasProperty('getDockerRegisteryAuth')) {
            def authInfo = getDockerRegisteryAuth(dockerBaseImage)
            println "Base image auth $dockerBaseImage username $authInfo"
            if (authInfo) {
                auth {
                    username = authInfo.user
                    password = authInfo.password
                }
            }
        }
    }

    extraDirectories {
        paths = [file('build/jib')]
        permissions = ['/docker_entrypoint.sh':'755']
    }

    to {
        image = dockerImage
        // https://github.com/GoogleContainerTools/jib/issues/2182
        credHelper = 'docker-credential-osxkeychain'
        tags = [env.toString() + '-' + (new Date().format("yyyyMMdd_HHmmss")).toString(), env.toString()]
        if (!executeDockerBuildLocal) {
            if (project.hasProperty('dockerUsername')) {
                auth {
                    println "image  $dockerImage username $dockerUsername"
                    username = dockerUsername
                    password = dockerPassword
                }
            }
        }
    }




    container {
        jvmFlags = jvmArgs
        mainClass = mainClassName
//        ports = [containerPort.toString(), debugServerPort.toString()]
        ports = [containerPort.toString()]
//        volumes = ['/userapp/data', '/userapp/logs', '/app/classes', '/app/resources', '/app/libs']
        volumes = ['/userapp',  '/app/']
        creationTime = 'USE_CURRENT_TIMESTAMP'
//      ENTRYPOINT ["java", jib.container.jvmFlags, "-cp", "/app/resources:/app/classes:/app/libs/*", jib.container.mainClass]
        if (file('docker_entrypoint.sh').exists()) {
            entrypoint = ['/bin/sh', '-c', '/docker_entrypoint.sh']
        }
    }
    allowInsecureRegistries = true
}


def updateServer(serverRole, execPath) {
    if (remotes.role(serverRole)) {
        ssh.run {
            session(remotes.role(serverRole)) {
                def gitRepo = "/home/${remote.user}/git-repo/${project.name}/"
                def dockerDir = gitRepo + "deploy/docker/"
                def updateScript = execPath
                executeScript """
                        cd ${gitRepo}
                        git pull 
                        cd ${dockerDir}
                        sh ${updateScript}
                """
                println "Deployed to ${remote.user}@${remote.host}:${gitRepo}"
            }
        }
    }
}

def updateSh = "./update_production.sh"

task dockerRestartProd() {
    doLast {
        def serverRole = 'production'
        updateServer(serverRole, updateSh)
        println "Restarted prod server"
    }
}

task dockerUpdateProd() {
    dependsOn 'jib'
    doLast {
        def serverRole = 'production'
        updateServer(serverRole, updateSh)
        println "Updated prod server"
    }
}

def rollbackSh = "./rollback_production.sh"
task dockerRollbackProd() {
    dependsOn 'jib'
    doLast {
        def serverRole = 'production'
        updateServer(serverRole, rollbackSh)
        println "Updated prod server"
    }
}


def updateTestSh = "./update_test.sh"
task dockerUpdateTest() {
    dependsOn 'jib'
    doLast {
        def serverRole = 'test'
        updateServer(serverRole, updateTestSh)
        println "Updated test server"
    }
}


def execCmd = { command ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine command
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

//task dockerUpdateLocal() {
//    dependsOn 'jibDockerBuild'
//    println(execCmd(['cd', 'deploy/docker', '&&', 'python3', './deploy.py', 'local']))
//}


task setupExtraDir {
    doLast {
        copy {
            from file('build/generated/git/')
            into file('build/jib/project/generated/git/')
        }
        copy {
            from file('src')
            into file('build/jib/project/src/')
        }
        copy {
            from file('build.gradle'), file('settings.gradle'), file('deploy')
            into file('build/jib/project/')
        }
        copy {
            from file('build/generated/docker_entrypoint.sh')
            into file('build/jib/')
        }
    }
}


tasks.jib.dependsOn tasks.build, tasks.setupExtraDir

tasks.jibDockerBuild.dependsOn tasks.build, tasks.setupExtraDir